// This file is automatically generated from /home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/rhost/Downloads/bro-2.4.1/build/src/analyzer/protocol/rsh/rsh_pac.h"

namespace binpac {






namespace RSH {
ContextRSH::ContextRSH(RSH_Conn * connection, RSH_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextRSH::~ContextRSH()
	{
	}

RSH_Conn::RSH_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new RSH_Flow(this);
	downflow_ = new RSH_Flow(this);
	bro_analyzer_ = bro_analyzer;
	}

RSH_Conn::~RSH_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void RSH_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void RSH_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void RSH_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

RegExMatcher RSH_PDU_re_001("[a-zA-Z0-9]*");

RegExMatcher RSH_PDU_re_002("[a-zA-Z0-9]*");

RegExMatcher RSH_PDU_re_003("(.*)/(.*)");

RSH_PDU::RSH_PDU()
	{
	pointO_ = 0;
	pointT_ = 0;
	byteorder_ = bigendian;
	proc_ = 0;
	}

RSH_PDU::~RSH_PDU()
	{
	clientUsername_.free();
	serverUsername_.free();
	restOfData_.free();
	}

int RSH_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextRSH * t_context)
	{
	// Parse "clientUsername"
	int t_clientUsername_string_length;
	t_clientUsername_string_length = 
		RSH_PDU_re_001.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_clientUsername_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh-protocol.pac:18", "[a-zA-Z0-9]*", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_clientUsername__size;
	t_clientUsername__size = t_clientUsername_string_length;
	// check for negative sizes
	if ( t_clientUsername_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh-protocol.pac:18", t_clientUsername_string_length);
	clientUsername_.init(t_begin_of_data, t_clientUsername_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_clientUsername = t_begin_of_data + (t_clientUsername__size);
	BINPAC_ASSERT(t_dataptr_after_clientUsername <= t_end_of_data);
	// Checking out-of-bound for "RSH_PDU:pointO"
	if ( t_dataptr_after_clientUsername + (1) > t_end_of_data || t_dataptr_after_clientUsername + (1) < t_dataptr_after_clientUsername )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RSH_PDU:pointO",
			((t_dataptr_after_clientUsername - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "pointO"
	pointO_ = *((uint8 const *) (t_dataptr_after_clientUsername));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "serverUsername"
	int t_serverUsername_string_length;
	t_serverUsername_string_length = 
		RSH_PDU_re_002.MatchPrefix(
			(t_dataptr_after_clientUsername + 1),
			t_end_of_data - (t_dataptr_after_clientUsername + 1));
	if ( t_serverUsername_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh-protocol.pac:20", "[a-zA-Z0-9]*", string((const char *) ((t_dataptr_after_clientUsername + 1)), (const char *) t_end_of_data).c_str());
		}
	int t_serverUsername__size;
	t_serverUsername__size = t_serverUsername_string_length;
	// check for negative sizes
	if ( t_serverUsername_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh-protocol.pac:20", t_serverUsername_string_length);
	serverUsername_.init((t_dataptr_after_clientUsername + 1), t_serverUsername_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_serverUsername = (t_dataptr_after_clientUsername + 1) + (t_serverUsername__size);
	BINPAC_ASSERT(t_dataptr_after_serverUsername <= t_end_of_data);
	// Checking out-of-bound for "RSH_PDU:pointT"
	if ( t_dataptr_after_serverUsername + (1) > t_end_of_data || t_dataptr_after_serverUsername + (1) < t_dataptr_after_serverUsername )
		{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("RSH_PDU:pointT",
			((t_dataptr_after_serverUsername - t_begin_of_data)) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "pointT"
	pointT_ = *((uint8 const *) (t_dataptr_after_serverUsername));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "restOfData"
	int t_restOfData_string_length;
	t_restOfData_string_length = 
		RSH_PDU_re_003.MatchPrefix(
			(t_dataptr_after_serverUsername + 1),
			t_end_of_data - (t_dataptr_after_serverUsername + 1));
	if ( t_restOfData_string_length < 0 )
		{
		throw binpac::ExceptionStringMismatch("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh-protocol.pac:22", "(.*)/(.*)", string((const char *) ((t_dataptr_after_serverUsername + 1)), (const char *) t_end_of_data).c_str());
		}
	int t_restOfData__size;
	t_restOfData__size = t_restOfData_string_length;
	// check for negative sizes
	if ( t_restOfData_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/rsh/rsh-protocol.pac:22", t_restOfData_string_length);
	restOfData_.init((t_dataptr_after_serverUsername + 1), t_restOfData_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_RSH_PDU__size;
	const_byteptr const t_dataptr_after_restOfData = (t_dataptr_after_serverUsername + 1) + (t_restOfData__size);
	BINPAC_ASSERT(t_dataptr_after_restOfData <= t_end_of_data);
	t_RSH_PDU__size = t_dataptr_after_restOfData - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_rsh_username(this);
	BINPAC_ASSERT(t_begin_of_data + (t_RSH_PDU__size) <= t_end_of_data);
	return t_RSH_PDU__size;
	}

RSH_Flow::RSH_Flow(RSH_Conn * connection)
	{
	connection_ = connection;
	dataunit_ = 0;
	context_ = 0;
	}

RSH_Flow::~RSH_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void RSH_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new RSH_PDU();
		context_ = new ContextRSH(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void RSH_Flow::NewGap(int gap_length)
	{
	}
void RSH_Flow::FlowEOF()
	{
	}
bool RSH_Flow::proc_rsh_username(RSH_PDU * msg)
	{

		BifEvent::generate_rsh_username(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn(),
       		 new StringVal(msg->clientUsername().length(), (const char*) msg->clientUsername().begin()),
	        new StringVal(msg->serverUsername().length(), (const char*) msg->serverUsername().begin()));
		return true;
		
	}

} // namespace RSH
}  // namespace binpac
