// This file is automatically generated from /home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/lol/lol.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/rhost/Downloads/bro-2.4.1/build/src/analyzer/protocol/lol/lol_pac.h"

namespace binpac {






namespace LOL {
ContextLOL::ContextLOL(LOL_Conn * connection, LOL_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextLOL::~ContextLOL()
	{
	}

LOL_Conn::LOL_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new LOL_Flow(this, true);
	downflow_ = new LOL_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

LOL_Conn::~LOL_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void LOL_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void LOL_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void LOL_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

LOL_PDU::LOL_PDU(bool is_orig)
	{
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	proc_ = 0;
	}

LOL_PDU::~LOL_PDU()
	{
	data_.free();
	}

int LOL_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextLOL * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/lol/lol-protocol.pac:18", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_LOL_PDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_LOL_PDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_lol_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_LOL_PDU__size) <= t_end_of_data);
	return t_LOL_PDU__size;
	}

LOL_Flow::LOL_Flow(LOL_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

LOL_Flow::~LOL_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void LOL_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new LOL_PDU(is_orig());
		context_ = new ContextLOL(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void LOL_Flow::NewGap(int gap_length)
	{
	}
void LOL_Flow::FlowEOF()
	{
	}
bool LOL_Flow::proc_lol_message(LOL_PDU * msg)
	{

		BifEvent::generate_lol_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn());
		return true;
		
	}

} // namespace LOL
}  // namespace binpac
