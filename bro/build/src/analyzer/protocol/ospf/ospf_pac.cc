// This file is automatically generated from /home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/ospf/ospf.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

#include "/home/rhost/Downloads/bro-2.4.1/build/src/analyzer/protocol/ospf/ospf_pac.h"

namespace binpac {






namespace OSPF {
ContextOSPF::ContextOSPF(OSPF_Conn * connection, OSPF_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextOSPF::~ContextOSPF()
	{
	}

OSPF_Conn::OSPF_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new OSPF_Flow(this, true);
	downflow_ = new OSPF_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

OSPF_Conn::~OSPF_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void OSPF_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void OSPF_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void OSPF_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

OSPF_PDU::OSPF_PDU(bool is_orig)
	{
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	proc_ = 0;
	}

OSPF_PDU::~OSPF_PDU()
	{
	data_.free();
	}

int OSPF_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextOSPF * t_context)
	{
	// Parse "data"
	int t_data_string_length;
	t_data_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_data__size;
	t_data__size = t_data_string_length;
	// check for negative sizes
	if ( t_data_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("/home/rhost/Downloads/bro-2.4.1/src/analyzer/protocol/ospf/ospf-protocol.pac:18", t_data_string_length);
	data_.init(t_begin_of_data, t_data_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_OSPF_PDU__size;
	const_byteptr const t_dataptr_after_data = t_begin_of_data + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_OSPF_PDU__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_ = t_context->flow()->proc_ospf_message(this);
	BINPAC_ASSERT(t_begin_of_data + (t_OSPF_PDU__size) <= t_end_of_data);
	return t_OSPF_PDU__size;
	}

OSPF_Flow::OSPF_Flow(OSPF_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

OSPF_Flow::~OSPF_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void OSPF_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new OSPF_PDU(is_orig());
		context_ = new ContextOSPF(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void OSPF_Flow::NewGap(int gap_length)
	{
	}
void OSPF_Flow::FlowEOF()
	{
	}
bool OSPF_Flow::proc_ospf_message(OSPF_PDU * msg)
	{

		BifEvent::generate_ospf_event(connection()->bro_analyzer(), connection()->bro_analyzer()->Conn());
		return true;
		
	}

} // namespace OSPF
}  // namespace binpac
